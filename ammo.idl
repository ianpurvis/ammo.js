interface btVector3 {
  attribute float[] m_floats;

  void btVector3();
  void btVector3(float x, float y, float z);

  float dot([Ref] btVector3 v);
  float length();
  float length2();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setValue(float x, float y, float z);
  float x();
  float y();
  float z();
  [Operator="*=", Ref] btVector3 op_mul(float x);
  [Operator="/=", Ref] btVector3 op_div(float x);
  [Operator="+=", Ref] btVector3 op_add([Ref] btVector3 v);
  [Operator="-=", Ref] btVector3 op_sub([Ref] btVector3 v);
};

interface btCollisionObject {
  void setActivationState(long newState);
};

interface btDispatcher {
};

interface btCollisionDispatcher {
  void btCollisionDispatcher(btCollisionConfiguration conf);
};
btCollisionDispatcher implements btDispatcher;

interface btBroadphaseInterface {
};

interface btDbvtBroadphase {
  void btDbvtBroadphase();
};
btDbvtBroadphase implements btBroadphaseInterface;

interface btCollisionConfiguration {
};

interface btConstraintSolver {
};

interface btSequentialImpulseConstraintSolver {
  void btSequentialImpulseConstraintSolver();
};
btSequentialImpulseConstraintSolver implements btConstraintSolver;

interface btSoftBodyWorldInfo {
  void btSoftBodyWorldInfo();
  [Value] attribute btVector3 m_gravity;
};

[Prefix="btSoftBody::"]
interface Face {
  attribute Node[] m_n;
  [Value] attribute btVector3 m_normal;
  attribute float m_ra;
};

[Prefix="btSoftBody::"]
interface tFaceArray {
  [Const] long size();
  [Const, Ref] Face at(long n);
};

[Prefix="btSoftBody::"]
interface Node {
  [Value] attribute btVector3 m_x;
  [Value] attribute btVector3 m_f;
};

[Prefix="btSoftBody::"]
interface tNodeArray {
  [Const] long size();
  [Const, Ref] Node at(long n);
};

[Prefix="btSoftBody::"]
interface Config {
  attribute float timescale;
  attribute long viterations;
  attribute long piterations;
  attribute long collisions;
};

interface btSoftBody {
  void btSoftBody(btSoftBodyWorldInfo worldInfo, long node_count, btVector3 x, float[] m);

  [Value] attribute Config m_cfg;
  [Value] attribute tNodeArray m_nodes;
  [Value] attribute tFaceArray m_faces;

  long generateBendingConstraints(long distance);
  long generateClusters(long k, optional long maxiterations);
  void setTotalMass(float mass, optional boolean fromfaces);
};
btSoftBody implements btCollisionObject;

interface btSoftBodyRigidBodyCollisionConfiguration {
  void btSoftBodyRigidBodyCollisionConfiguration();
};
btSoftBodyRigidBodyCollisionConfiguration implements btCollisionConfiguration;

interface btSoftBodySolver {
};

interface btDefaultSoftBodySolver {
  void btDefaultSoftBodySolver ();
};
btDefaultSoftBodySolver implements btSoftBodySolver;

interface btSoftBodyArray {
  [Const] long size();
  [Const] btSoftBody at(long n);
};

interface btSoftRigidDynamicsWorld {
  void btSoftRigidDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, btSoftBodySolver softBodySolver);

  void addSoftBody(btSoftBody body, optional short collisionFilterGroup, optional short collisionFilterMask);
  [Ref] btSoftBodyWorldInfo getWorldInfo();
  void removeSoftBody(btSoftBody body);
  void setGravity([Ref] btVector3 gravity);
  long stepSimulation(float timeStep, optional long maxSubSteps, optional float fixedTimeStep);
};

interface btSoftBodyHelpers {
  void btSoftBodyHelpers();

  btSoftBody CreateFromTriMesh([Ref] btSoftBodyWorldInfo worldInfo, float[] vertices, long[] triangles, long ntriangles, boolean randomizeConstraints);
};
